name: Cache Docker images using GitHub Actions cache

description: |
  This GitHub Action caches Docker images using the GitHub Actions cache service. 
  It downloads the latest version of the Docker image and caches it for subsequent runs.

inputs:
  docker-image:
    description: 'The name of the Docker image to cache'
    required: true
    default: 'docker-image'
  docker-user:
    description: 'The docker registry user'
    required: false
    default: ''
  docker-password:
    description: 'The docker registry password'
    required: false
    default: ''
  cache-path:
    description: 'The path to the directory where the Docker image should be cached'
    required: false
    default: 'ci/cache/docker'

outputs:
  cache-hit:
    description: 'Whether the Docker image was restored from the cache'
    value: ${{ steps.cache-docker.outputs.cache-hit }}

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      
    - name: Get Docker image digest
      id: get-digest
      shell: bash
      env:
        DOCKER_IMAGE: ${{ inputs.docker-image }}
      run: |
        # Extract the registry, image name, and tag from the Docker image string
        # Examples: "ghcr.io/jitsecurity-controls/control-gitleaks-alpine:tag"
        #           "121169888995.dkr.ecr.us-east-1.amazonaws.com/control-legitify-alpine:latest"
        #           "shlomik/aws-batch-test:latest"
        #           "shlomik/aws-batch-test"
        export REGISTRY=$(echo "${DOCKER_IMAGE}" | awk -F/ '{print $1}')
        export IMAGE_NAME_WITH_TAG=$(echo "${DOCKER_IMAGE}" | awk -F/ '{print $NF}')
        export IMAGE_NAME=$(echo "${IMAGE_NAME_WITH_TAG}" | awk -F: '{print $1}')
        export DOCKER_TAG=$(echo "${IMAGE_NAME_WITH_TAG}" | awk -F: '{print $2}')
        if [ -z "${DOCKER_TAG}" ]; then DOCKER_TAG="latest"; fi
        
        # Get the Docker image digest from the registry API
        if [ "${REGISTRY}" = "ghcr.io" ]; then
          echo ========
          export DIGEST=$(docker manifest inspect ${{ inputs.docker-image }} | jq '.manifests[0].digest' | cut -d'"' -f2)
          if [ -z "$DIGEST" ]; then
            export DIGEST=$(docker manifest inspect ${{ inputs.docker-image }} | jq '.config.digest' | cut -d'"' -f2)
          fi
          echo $DIGEST
          echo ========
          ## For GitHub Container Registry (ghcr.io), use the GitHub API token for authentication
          # TOKEN=$(curl -s -H "Authorization: Bearer ${{ inputs.docker-password }}" "https://ghcr.io/auth/token" | jq -r '.token')
          # export DIGEST=$(curl -s -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -H "Authorization: Bearer $TOKEN" "https://ghcr.io/v2/${IMAGE_NAME}/manifests/${DOCKER_TAG}" | jq -r '.config.digest')
        elif [[ "${REGISTRY}" =~ .*\.dkr\.ecr\..*\.amazonaws\.com ]]; then
          # For Amazon Elastic Container Registry (ECR), use the AWS CLI to get a temporary token for authentication
          # export AWS_ACCESS_KEY_ID="${{ inputs.docker-user }}"
          export AWS_SECRET_ACCESS_KEY="${{ inputs.docker-password }}"
          export AWS_ACCOUNT_ID=$(echo "${REGISTRY}" | cut -d'.' -f1)
          export TOKEN=$(aws ecr get-login-password | docker login --username AWS --password-stdin "${REGISTRY}")
          export DIGEST=$(curl -s -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -H "Authorization: Bearer $TOKEN" "https://${REGISTRY}/v2/${IMAGE_NAME}/manifests/${DOCKER_TAG}" | jq -r '.config.digest')
        else
          # For other registries (e.g., Docker Hub), use anonymous authentication
          export DIGEST=$(curl -s -H "Accept: application/vnd.docker.distribution.manifest.v2+json" "https://registry-1.docker.io/v2/${IMAGE_NAME}/manifests/${DOCKER_TAG}" | jq -r '.config.digest')
        fi
        
        # Set the environment variables for the digest and image name with tag
        export IMAGE_NAME_WITH_TAG="${IMAGE_NAME}:${DOCKER_TAG}"
        echo "digest=${DIGEST}" >> $GITHUB_ENV
        echo "image-name=${IMAGE_NAME_WITH_TAG}" >> $GITHUB_ENV

    - name: print cache1
      id: print-cache1
      shell: bash
      run: |
        if [ -d ${{ inputs.cache-path }} ]; then
          echo ------cache------
          ls -la ${{ inputs.cache-path }}
        else
          echo "Cache file doesn't exist yet"
        fi
        
        
    - name: Restore Docker image from cache
      id: cache-docker
      uses: actions/cache@v3
      with:
        path: ${{ inputs.cache-path }}
        key: ${{ env.image-name }}@${{ env.digest }}
        restore-keys: ${{ env.image-name }}
        
    - name: print cache2
      id: print-cache2
      shell: bash
      run: |
        if [ -d ${{ inputs.cache-path }} ]; then
          echo ------cache2------
          ls -la ${{ inputs.cache-path }}
        else
          echo "Cache file doesn't exist yet"
        fi

    - name: Pull latest Docker image
      id: pull-image
      shell: bash
      run: |
        if [ -f ${{ inputs.cache-path }}/${{ env.image-name }}.tar ]; then
          docker image load --input ${{ inputs.cache-path }}/${{ env.image-name }}.tar
        else
          echo "Cache file doesn't exist"
        fi
        docker pull ${{ inputs.docker-image }}
        mkdir -p ${{ inputs.cache-path }}
        echo ---1---
        ls -l ${{ inputs.cache-path }}/
        rm -f ${{ inputs.cache-path }}/${{ env.image-name }}*
        echo ---2---
        ls -l ${{ inputs.cache-path }}/
        docker image save ${{ inputs.docker-image }} --output ${{ inputs.cache-path }}/${{ env.image-name }}.tar
        
    - name: ls dir again
      id: ls-dir
      shell: bash
      run: |
        echo ---3---
        ls -l ${{ inputs.cache-path }}/
        echo ---4---


#     - name: Save Docker image to cache
#       if: steps.cache-docker.outputs.cache-hit != 'true'
#       shell: bash
#       run: |
#         mkdir -p ${{ inputs.cache-path }}
#         docker image save -o ${{ inputs.cache-path }}/${{ env.image-name }}@${{ env.digest }}.tar ${{ inputs.docker-image }}

#     - name: Save cache
#       if: steps.cache-docker.outputs.cache-hit != 'true'
#       uses: actions/cache@v2
#       with:
#         path: ${{ inputs.cache-path }}
#         key: ${{ env.image-name }}@${{ env.digest }}
#        restore-keys: ${{ env.image-name }}
